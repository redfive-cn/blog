---
title: JMM学习
layout: article
tags: learn JMM
---

## java运行时数据区模型

![java虚拟机运行时数据区](/img/learn/gc/jmm模型.png)

### 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，线程私有，它可以看作是当前线程所执行的字节码的行号指示器。
### java虚拟机栈
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。
虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，
Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
### 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，
其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
### java堆
对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。
Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。
### 方法区
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，
它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），
目的是与Java堆区分开来。
### 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。
Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），
用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
### 直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。
### 元数据空间(Metaspace)
jdk8以后不再使用永久代(PermGen space)，引入了元数据空间。
### 垃圾收集器
#### GC分析算法
1.引用计数算法
2.可达性分析算法
#### 引用类型
1.强引用：即赋值引用，如`Object obj = new Object()`。

2.软引用：内存溢出前，会回收所有软引用，如果还没有足够内存，会抛出内存溢出。

3.弱引用：回收时一定会被回收的对象。

4.虚引用：不对对象生存时间产生影响，只是回收时受到系统的一个通知。PhantomReference
#### finalize方法
如果一个对象被可达性分析标记为未被引用，会被第一次标记；如果对象覆盖finalize()方法，并且该方法没被调用过，会被第二次标记，如果两次标记均命中，则对象正式死亡。

需要执行finalize方法的对象会被置于F-Queue队列，由一个低调度优先级的Finalizer线程执行finalize方法，如果这个队列发生了阻塞或者执行缓慢，
将会导致内存回收子系统的崩溃，引发内存溢出，所以**一般不建议覆写finalize方法**。

#### 常见GC Collector
##### CMS收集器
基于清除-标记算法实现的，整个过程分为四个步骤：

1.初始标记（CMS initial mark）

2.并发标记（CMS concurrent mark）

3.重新标记（CMS remark）

4.并发清除（CMS concurrent sweep）
###### 缺点
1.对cpu资源敏感

2.无法处理浮动垃圾。
```
在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，
但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。

收集器与用户线程并发执行会导致两种错误后果：把原本消亡的对象标记为存活；把原本存活的对象标记为消亡。后者是不可接受的。
为了解决这个问题，在并发标记阶段，使用增量更新记录指向存活对象的新增引用，在重新标记阶段将这些新增引用设置为存活。
重新标记并不能消除浮动垃圾。
```
3.标记-清除算法的通病：产生大量空间碎片。
##### G1收集器
G1是一种并发、并行、部分Stop The World、使用Copying算法收集的分代的增量式收集器，
G1的全堆的操作，像global marking，是和应用(mutator)并发执行的，这样可以减少对mutator的暂停时间。清除阶段则使用多线程来提高吞吐量。
G1追求高吞吐与可预测的停顿时间。

大体可分为四个步骤执行步骤

1.初始标记

2.并发标记

3.最终标记：处理SATB记录（也是为了将错标记为消亡的对象重新标记为存活）

4.筛选标记：
